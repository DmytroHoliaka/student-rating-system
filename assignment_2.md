# Assignment #2. Text files processing

Тут написані не типова купа сміття типу "вступ", "висновки", а реально важливі речі, які слід знати перед тим, як здавати лаби: ситуація дещо відрізняється від інших лабораторних в університеті. Тому прочитайте уважно.

Кожна робота має виконуватися в окремому репозиторії. Зробити всі лабораторні в різних підпапках одного репозиторію - це не різні репозиторії :)

Кожну лабу треба з самого початку писати, використовуючи git. В такого рішення є щонайменше дві причини:

* без знання git/mercurial ви не станете професійним розробником
* уникнення ~~копіпасти~~ академічної недоброчесності.

Якщо в репозиторії буде всього 3-4 комміти - це не вважається використанням git, така робота не прийматиметься. Спробуйте робити комміти частіше, щоб це увійшло в звичку - вона значно зекономить вам час у майбутньому.

Не заливайте файли на гіт через web-інтерфейс, це незручно і довго. Замість нього можна використовуватии різноманітні git клієнти (SmartGit або GitKraken, наприклад), або ж консоль, яка може бути як окремою, так і вбудованою в вашу IDE. 
Абсолютно нормально, якщо ви так будете заливати один-два файли (не код) або нашвидкоруч виправите маленькі недоліки, проте якщо більшість ваших коммітів будуть такими, робота не буде прийнята.

Варіант завдання – остача від ділення номеру в списку на 3. 

## Прочитайте уважно, перш ніж виконувати завдання

Не використовуйте сторонні чи вбудовані засоби для розбору файлів csv, частина завдання – навчитися робити це власноруч.

## Питання та необхідні знання
Для успішної здачі роботи вам треба:
* Вміти виконувати операції над текстовими файлами (читання, обробка, запис), розуміти призначення формату .csv 
* Вміти знаходити файли в папках за допомогою обраної вами мови програмування. 
* Буде плюсом розібратись з іншими форматами для подання даних
* Розібратись з основами роботи в git не тільки в git-game, але і в реальних умовах, коли ви робите справжні зміни в код. Як мінімум вам знадобляться команди add, commit, checkout, merge, rebase. Спробуйте також використовувати revert та reset, якщо ви наробили дурниць і хочете все виправити. Якщо ви ще не робили першу роботу, зараз саме час: вона познайомить вас із основами git, щоб ви не відволікались на них при виконанні цієї.
* Як хороші додаткові знання, які рано чи пізно знадобляться – stash, interactive rebase. Взагалі круто – [git flow](https://habrahabr.ru/post/106912/), але якщо ви тільки знайомитесь з гітом, залиште це на потім.
* Під час здачі роботи буде завдання, що полягатиме у навмисному створенні конфліктів при merge або rebase, які ви матимете вирішити.
* Запропоноване програмне рішення має бути гнучким

Цілком можливо, у вас виникнуть проблеми з кириличним кодуванням символів. В сучасних мовах програмування найчастіше використовують кодування Unicode, де кожен символ може займати різну кількість байтів у пам'яті, а не лише 1 ([це як?](http://unicode.org/faq/utf_bom.html)). 

## Варіант #0
Реалізувати складання списку студентів, що отримують стипендію. На вхід подається назва директорії, всередині якої необхідно зчитати всі текстові файли .csv. Перший рядок кожного файлу містить ціле число – кількість студентів, що записані в файлі, всі інші рядки мають такий формат:
`Прізвище, предмет №1,№2,№3,№4,№5, ..., контрактник`, наприклад

```csv
2
Ivanov,78,61,95,87,90,FALSE   // (82.8)
Petrov,85,66,70,99,100,TRUE   // (84)
```

Необхідно розібрати всі такі файли в папці з прикладами та вашим варіантом, скласти одну велику таблицю, підрахувати для кожного студента-бюджетника середній бал та вивести вищі 40% сумарного рейтингу студентів + мінімальний бал для отримання стипендії. 

#### Вхідні та вихідні дані
На вхід програми подається назва теки. Вивід – файл rating.csv з прізвищами студентів-стипендіатів та їх середній бал (до третього знаку). Мінімальний бал для стипендії можна вивести в stdout.
Вихідні дані повинні містити єдиний результат виконання для всіх файлів вхідної директорії.


## Варіант #1
Ваше завдання: визначити список країн-переможців у конкурсі Допобачення-2020. На вхід подається назва директорії, всередині якої необхідно зчитати всі текстові файли .csv. Всі всі такі файли в папці з прикладами та вашим варіантом, мають такий формат `Країна, кількість голосів за у країні №1-№20`, наприклад:
```csv
1
Ukraine,78000,6156,495,7,9456460,45645,21213,898...
```
Перший рядок містить кількість країн, що знаходяться в кожному з файлів.
Кожен наступний рядок містить кількість голосів від кожної з країн-учасниць. У прикладі вище Україна отримала 78000 голосів від країни №1, 6156 голосів від країни №2 тощо. Країна, що набрала найбільшу кількість голосів (в стовпчику) отримує 12 балів, друге місце – 10, з третього по десяте – 8-1 бал відповідно. Необхідно порахувати сумарну кількість балів за кожну країну і вивести топ-10 переможців у текстовий файл.

#### Вхідні та вихідні дані
На вхід програми подається назва теки. Вивід – файл results.csv з результатами найкращих десяти країн Допобачення-2020.
Вихідні дані повинні містити єдиний результат виконання для всіх файлів вхідної директорії.

## Варіант #2
Визначити загальну кількість очок кожної команди на чемпіонаті Англії з футболу. Результати матчів подано в всі такі файли в папці з прикладами та вашим варіантом, наступному форматі – `Назва команди, результати матчу №1-№10`, наприклад:
```csv
1
Chelsea FC,3:0,0:0,1:0,0:2,4:1,3:1,0:3,1:5,0:2,4:1
```
Перший рядок задає кількість команд, результати яких знаходяться в цьому файлі.

Результат матчу подається у форматі `A:B`, де А – результат команди, В – результат супротивника. За перемогу команда отримує 3 очка, за нічию – 1, за програш – 0. Необхідно вивести підсумкову таблицю чемпіонату.

#### Вхідні та вихідні дані
На вхід програми подається назва теки. Вивід – файл results.csv з результатами всіх команд ліги.
Вихідні дані повинні містити єдиний результат виконання для всіх файлів вхідної директорії.

#### Теоретичні питання 
Основи і типи  
1. Яким чином при запуску проекту виконання коду починається з функції main ? 
2. Що таке callstack? 
3. Що таке куча? 
4. callstack це власність потоку чи  процесу? 
5. куча є власністю потоку чи процесу ?  
6. char * arraypointer як зберігається в памяті ? 
7. char ** arrayPointer як зберігається в памяті ? 
8. char * arrayPointer[20] як зберігається в памяті ? 
9. string str = ""; як зберігається в памяті ?  
10. опціональне питання string *str як зберігається в памяті ?  
11. string str = "", str1="", str2 = str + str1; як працює конкатинація строк і що при її виконанні відбуватиметься в пам'яті? (опційно чи зміниться процес збереження даних в памяті якщо  використати вказівник та конструктор ) 
12. Аргументи функції мейн, які вони та як їх передати ? 
Опційно 
13. цикл обробки подій windows (1 глава  https://studfile.net/preview/9245192/ - можете пошукати англійською, державною теж немає) 

Файли
1. Що таке файловий дескриптор ? 
2. Чи є можливість з файлового показчика або  об'єкту файлового потоку отримати файловий дескриптор ?    
3. Як зберігатиметься в пам'яті 
3.1. fstream/ifstream file
3.2. fstream/ifstream *file
3.3. FILE * file  
4. Чому не достатньо звичайного очищення об'єкту або видалення файлового показчика, і необхідно викликати метод close? 
5. Що таке файловий дескриптор ? 
6. Що таке некерований ресурс, зовняшній ресурс ? 
7. Як відбувається програмне закриття файлу ? 
8. Чим файлові потоки відрізняються від вказівника на файл ? 
9. Флаги та аргументи з якими можна відкривати файли (доступ, тип файлу і тд) 
Опційне  : 
10. Буферизоване читання, спосіб роботи оптимальний розмір буферу величина і чому ?  
11. Потокове читання навігація по потоку даних, функції що це забезпечують. 
12. Коли буде викликано flush? 
13. Стандартні методи і константи при роботі з файлами. 

Строки
1. Що таке кодування, які вони бувають, яке стандартне для char (ASCII unicode) 
2. Знати та розуміти як працюють всі функції з string.h та методи класу string
Опційно  
3. Конструктори і особливості створення строк 
4. Як працюють операції виводу для масиву char і строк, чому не потрібно ітеруватись для виводу всіх символів 
5. \0 навіщо цей символ і чому виведення буде працювати не коректно без нього

Якщо використовуватимете ООП, то прочитайте трошки про архітектуру і SOLID 
0. Статика, коли її варто використовувати а коли ні та чому (корисне посилання, але не на державній мові, нажаль https://habr.com/ru/post/527044/,  можна знайти і англійською)? 
1. SOLID. саме просте пояснення на професорі веб, але не державною.
взаємо зв'язок між: 
1.1. Наслідуванням та Open-close принципом 
1.2. Поліморфізм та  liskov substitution 
1.3. dependency injection, як спосіб досягнення слабкої зв'язності коду 1.4. інєкція залежностей, її види та способи застосування
2. Поведінкові та не поведінкові класи, DTO(як приклад класу контейнера) vs BL class 
3*. N-tier architecture, Anemic Domain Model vs Rich domain model (простий опис https://youtu.be/Iu_BBPbpPLE)
4**. Chain Of Responsibility Design Pattern GOF